{"version":3,"sources":["../src/index.ts","../src/context/MouseContext.ts","../src/context/MouseRegistryContext.ts","../src/geometry/hooks.ts","../src/geometry/utils.ts","../src/hooks/useMouse.ts","../src/constants.ts","../src/hooks/useMouseEventInternal.ts","../src/hooks/useOnClick.ts","../src/hooks/useOnDrag.ts","../src/hooks/useOnMouseEnter.ts","../src/hooks/useOnMouseLeave.ts","../src/hooks/useOnMouseMove.ts","../src/hooks/useOnPress.ts","../src/hooks/useOnRelease.ts","../src/hooks/useOnWheel.ts","../src/provider/MouseProvider.tsx","../src/utils/geometry.ts","../src/hooks/createMouseEventHandlers.ts","../src/hooks/useElementBoundsCache.ts","../src/hooks/useMouseInstance.ts","../src/utils/events.ts"],"sourcesContent":["// Types\n\n// Context (exported for advanced use cases)\nexport { MouseContext } from './context';\n// Geometry functions\nexport {\n  getBoundingClientRect,\n  getElementDimensions,\n  getElementPosition,\n  useBoundingClientRect,\n  useElementDimensions,\n  useElementPosition,\n} from './geometry';\n// Hooks\nexport {\n  useMouse,\n  useOnClick,\n  useOnDrag,\n  useOnMouseEnter,\n  useOnMouseLeave,\n  useOnMouseMove,\n  useOnPress,\n  useOnRelease,\n  useOnWheel,\n} from './hooks';\n// Provider\nexport { MouseProvider } from './provider';\nexport type {\n  BoundingClientRect,\n  ClickHandler,\n  DOMRect,\n  ElementRef,\n  InkMouseEvent,\n  MouseContextValue,\n  MouseDragHandler,\n  MouseEnterHandler,\n  MouseLeaveHandler,\n  MouseMoveHandler,\n  MousePressHandler,\n  MouseReleaseHandler,\n  WheelHandler,\n} from './types';\n\n// Utilities\nexport * from './utils';\n","import { createContext } from 'react';\nimport type { MouseContextValue } from '../types';\n\n/**\n * React context for mouse functionality\n * Provides access to mouse instance and control methods\n */\nexport const MouseContext: React.Context<MouseContextValue | null> = createContext<MouseContextValue | null>(null);\n","import { createContext } from 'react';\nimport type { MouseRegistryContextValue } from '../types';\n\n/**\n * Internal React context for handler registry\n * Used by hooks to register/unregister event handlers\n */\nexport const MouseRegistryContext: React.Context<MouseRegistryContextValue | null> =\n  createContext<MouseRegistryContextValue | null>(null);\n","import type { DOMElement } from 'ink';\nimport type { RefObject } from 'react';\nimport { useEffect, useState } from 'react';\nimport type { BoundingClientRect } from '../types';\nimport { getBoundingClientRect, getElementDimensions, getElementPosition } from './utils';\n\n/**\n * Stateful hook to provide the position of the referenced element.\n *\n * @param ref - The reference to the element.\n * @param deps - Dependencies to recompute the position.\n * @returns The position of the element.\n */\nexport function useElementPosition(\n  ref: RefObject<DOMElement | null>,\n  deps: unknown[] = [],\n): { left: number; top: number } {\n  const [position, setPosition] = useState<{\n    left: number;\n    top: number;\n  }>({\n    top: 0,\n    left: 0,\n  });\n\n  useEffect(\n    function UpdatePosition() {\n      const position = getElementPosition(ref.current);\n      if (!position) {\n        return;\n      }\n      setPosition(position);\n    },\n    // biome-ignore lint/correctness/useExhaustiveDependencies: deps is a parameter for flexibility\n    deps,\n  );\n\n  return position;\n}\n\nexport function useElementDimensions(\n  ref: RefObject<DOMElement | null>,\n  deps: unknown[] = [],\n): { width: number; height: number } {\n  const [dimensions, setDimensions] = useState<{\n    width: number;\n    height: number;\n  }>({\n    width: 0,\n    height: 0,\n  });\n\n  useEffect(\n    function UpdateDimensions() {\n      const dimensions = getElementDimensions(ref.current);\n      if (!dimensions) {\n        return;\n      }\n      setDimensions(dimensions);\n    },\n    // biome-ignore lint/correctness/useExhaustiveDependencies: deps is a parameter for flexibility\n    deps,\n  );\n\n  return dimensions;\n}\n\n/**\n * Hook to get the bounding client rect of a referenced element.\n *\n * @param ref - The reference to the element.\n * @param deps - Dependencies to recompute the bounding rect.\n * @returns The bounding client rect of the element.\n */\nexport function useBoundingClientRect(ref: RefObject<DOMElement | null>, deps: unknown[] = []): BoundingClientRect {\n  const [rect, setRect] = useState<BoundingClientRect>({\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n  });\n\n  useEffect(\n    function UpdateBoundingClientRect() {\n      const rect = getBoundingClientRect(ref.current);\n      if (!rect) {\n        return;\n      }\n      setRect(rect);\n    },\n    // biome-ignore lint/correctness/useExhaustiveDependencies: deps is a parameter for flexibility\n    deps,\n  );\n\n  return rect;\n}\n","import type { DOMElement } from 'ink';\nimport type { BoundingClientRect } from '../types';\n\n/**\n * Get the dimensions of the element.\n */\nexport function getElementDimensions(node: DOMElement | null): { width: number; height: number } | undefined {\n  const elementLayout = node?.yogaNode?.getComputedLayout();\n\n  if (!elementLayout) {\n    return;\n  }\n\n  return {\n    width: elementLayout.width,\n    height: elementLayout.height,\n  };\n}\n\n/**\n * Get the position of the element.\n */\nexport function getElementPosition(node: DOMElement | null): { left: number; top: number } | undefined {\n  if (!node) {\n    return;\n  }\n  const { left, top } = walkNodePosition(node);\n\n  return {\n    left,\n    top,\n  };\n}\n\n/**\n * Walks the node's ancestry to calculate its absolute position.\n *\n * This function traverses up the parent chain of a DOMElement, accumulating\n * the `left` and `top` layout values to determine the element's final\n * absolute position within the Ink rendering context.\n *\n * Note: The initial `left` and `top` values are set to 1 because terminal\n * coordinates are 1-indexed. Relative coordinates of each element, however,\n * start from 0.\n *\n * Since InkNodes are relative by default and because Ink does not\n * provide precomputed x and y values, we need to walk the parent and\n * accumulate the x and y values.\n *\n * @param node - The DOMElement for which to calculate the position.\n * @returns An object containing the calculated `left` and `top` absolute coordinates.\n */\nfunction walkNodePosition(node: DOMElement): { left: number; top: number } {\n  let current: DOMElement | undefined = node;\n  let left = 1;\n  let top = 1;\n\n  while (current) {\n    if (!current.yogaNode) {\n      return { left, top };\n    }\n\n    const layout = current.yogaNode.getComputedLayout();\n    left += layout.left;\n    top += layout.top;\n\n    current = current.parentNode;\n  }\n  return { left, top };\n}\n\n/**\n * Get the bounding client rect of an element.\n *\n * @param node - The DOMElement node.\n * @returns The bounding client rect or undefined if node is null.\n */\nexport function getBoundingClientRect(node: DOMElement | null): BoundingClientRect | undefined {\n  if (!node) {\n    return;\n  }\n\n  const position = getElementPosition(node);\n  const dimensions = getElementDimensions(node);\n\n  if (!position || !dimensions) {\n    return;\n  }\n\n  const { left, top } = position;\n  const { width, height } = dimensions;\n\n  const right = left + width;\n  const bottom = top + height;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    x: left,\n    y: top,\n  };\n}\n","import { useContext } from 'react';\nimport { Mouse } from 'xterm-mouse';\nimport { DEV_WARNING, ERRORS } from '../constants';\nimport { MouseContext } from '../context';\n\ntype UseMouseReturn = {\n  isEnabled: boolean;\n  isTracking: boolean;\n  isSupported: boolean;\n  enable: () => void;\n  disable: () => void;\n};\n\n/**\n * Hook for accessing mouse control and state\n * Must be used within a MouseProvider\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const mouse = useMouse();\n *\n *   return (\n *     <Box>\n *       <Text>Mouse enabled: {mouse.isEnabled}</Text>\n *       <Text>Supported: {mouse.isSupported}</Text>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useMouse(): UseMouseReturn {\n  const context = useContext(MouseContext);\n\n  if (!context) {\n    throw new Error(`${DEV_WARNING} ${ERRORS.NO_PROVIDER}`);\n  }\n\n  const isSupported = Mouse.isSupported();\n\n  return {\n    ...context,\n    isSupported,\n  };\n}\n","/**\n * Mouse event types from xterm-mouse\n */\nexport const MOUSE_EVENTS = {\n  PRESS: 'press',\n  RELEASE: 'release',\n  CLICK: 'click',\n  WHEEL: 'wheel',\n  MOVE: 'move',\n  DRAG: 'drag',\n} as const;\n\n/**\n * Default options for MouseProvider\n */\nexport const DEFAULT_PROVIDER_OPTIONS = {\n  autoEnable: true,\n  cacheInvalidationMs: 16, // ~60fps\n} as const;\n\n/**\n * Development mode warning prefix\n */\nexport const DEV_WARNING = '[ink-mouse]';\n\n/**\n * Error messages\n */\nexport const ERRORS = {\n  NO_PROVIDER:\n    // biome-ignore lint/security/noSecrets: This is an error message, not a secret\n    'Mouse hooks must be used within a MouseProvider. Wrap your component tree with <MouseProvider>.',\n  NOT_SUPPORTED: 'Terminal does not support mouse events',\n  NULL_REF: 'ref is null or undefined',\n  NULL_HANDLER: 'handler is null or undefined',\n} as const;\n","import { useContext, useEffect, useRef } from 'react';\nimport { DEV_WARNING, ERRORS } from '../constants';\nimport { MouseRegistryContext } from '../context';\nimport type { ElementRef, InkMouseEvent } from '../types';\n\n/**\n * Internal universal hook for mouse event registration\n * Handles common logic for all mouse event hooks\n *\n * @internal\n */\nexport function useMouseEventInternal(\n  eventType:\n    | 'click'\n    | 'mouseEnter'\n    | 'mouseLeave'\n    | 'mousePress'\n    | 'mouseRelease'\n    | 'mouseMove'\n    | 'mouseDrag'\n    | 'wheel',\n  ref: ElementRef,\n  handler: ((event: InkMouseEvent) => void) | null | undefined,\n): void {\n  const registry = useContext(MouseRegistryContext);\n  const idRef = useRef<string | null>(null);\n\n  // Generate unique ID with event type\n  if (idRef.current === null) {\n    idRef.current = `${eventType}-${Date.now()}-${Math.random()}`;\n  }\n\n  useEffect(() => {\n    if (!registry) {\n      throw new Error(`${DEV_WARNING} ${ERRORS.NO_PROVIDER}`);\n    }\n\n    if (!ref) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`${DEV_WARNING} ${ERRORS.NULL_REF}`);\n      }\n      return;\n    }\n\n    if (!handler) {\n      return;\n    }\n\n    const id = idRef.current;\n    if (!id) {\n      return;\n    }\n\n    registry.registerHandler(id, ref, eventType, handler);\n\n    return () => {\n      registry.unregisterHandler(id);\n    };\n  }, [ref, handler, registry, eventType]);\n}\n","import type { ClickHandler, ElementRef } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling click events on an element.\n * Must be used within a MouseProvider.\n *\n * @param ref - Reference to the element.\n * @param handler - Click event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Clickable() {\n *   const ref = useRef<DOMElement>(null);\n *\n *   useOnClick(ref, (event) => {\n *     console.log('Clicked at', event.x, event.y);\n *   });\n *\n *   return <Box ref={ref}>Click me</Box>;\n * }\n * ```\n */\nexport function useOnClick(ref: ElementRef, handler: ClickHandler | null | undefined): void {\n  useMouseEventInternal('click', ref, handler);\n}\n","import type { ElementRef, MouseDragHandler } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling mouse drag events on an element.\n * Must be used within a MouseProvider.\n *\n * Drag events fire when the mouse moves while a button is held down.\n * This is useful for implementing drag-and-drop functionality.\n *\n * @param ref - Reference to the element.\n * @param handler - Mouse drag event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Draggable() {\n *   const ref = useRef<DOMElement>(null);\n *   const [isDragging, setIsDragging] = useState(false);\n *   const [position, setPosition] = useState({ x: 0, y: 0 });\n *\n *   useOnPress(ref, () => setIsDragging(true));\n *   useOnRelease(ref, () => setIsDragging(false));\n *\n *   useOnDrag(ref, (event) => {\n *     if (isDragging) {\n *       setPosition({ x: event.x, y: event.y });\n *     }\n *   });\n *\n *   return (\n *     <Box ref={ref} flexDirection=\"column\">\n *       <Text>Position: {position.x}, {position.y}</Text>\n *       <Text>{isDragging ? '(dragging)' : '(not dragging)'}</Text>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useOnDrag(ref: ElementRef, handler: MouseDragHandler | null | undefined): void {\n  useMouseEventInternal('mouseDrag', ref, handler);\n}\n","import type { ElementRef, MouseEnterHandler } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling mouse enter events on an element.\n * Must be used within a MouseProvider.\n *\n * @param ref - Reference to the element.\n * @param handler - Mouse enter event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Component() {\n *   const ref = useRef<DOMElement>(null);\n *   const [message, setMessage] = useState('');\n *\n *   useOnMouseEnter(ref, () => setMessage('Mouse entered!'));\n *\n *   return (\n *     <Box ref={ref}>\n *       <Text>{message}</Text>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useOnMouseEnter(ref: ElementRef, handler: MouseEnterHandler | null | undefined): void {\n  useMouseEventInternal('mouseEnter', ref, handler);\n}\n","import type { ElementRef, MouseLeaveHandler } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling mouse leave events on an element.\n * Must be used within a MouseProvider.\n *\n * @param ref - Reference to the element.\n * @param handler - Mouse leave event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Component() {\n *   const ref = useRef<DOMElement>(null);\n *   const [message, setMessage] = useState('');\n *\n *   useOnMouseLeave(ref, () => setMessage('Mouse left!'));\n *\n *   return (\n *     <Box ref={ref}>\n *       <Text>{message}</Text>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useOnMouseLeave(ref: ElementRef, handler: MouseLeaveHandler | null | undefined): void {\n  useMouseEventInternal('mouseLeave', ref, handler);\n}\n","import type { ElementRef, MouseMoveHandler } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling mouse move events on an element.\n * Must be used within a MouseProvider.\n *\n * Move events fire when the mouse cursor moves within the element's bounds.\n * Unlike hover events, move events fire continuously as the mouse moves.\n *\n * **Performance Note:** Move events fire very frequently. Consider debouncing\n * or throttling handlers for performance-sensitive applications.\n *\n * @param ref - Reference to the element.\n * @param handler - Mouse move event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Tracker() {\n *   const ref = useRef<DOMElement>(null);\n *   const [position, setPosition] = useState({ x: 0, y: 0 });\n *\n *   useOnMouseMove(ref, (event) => {\n *     setPosition({ x: event.x, y: event.y });\n *   });\n *\n *   return (\n *     <Box ref={ref}>\n *       <Text>Mouse position: {position.x}, {position.y}</Text>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useOnMouseMove(ref: ElementRef, handler: MouseMoveHandler | null | undefined): void {\n  useMouseEventInternal('mouseMove', ref, handler);\n}\n","import type { ElementRef, MousePressHandler } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling mouse button press events on an element.\n * Must be used within a MouseProvider.\n *\n * Press events fire immediately when a mouse button is pressed down,\n * before the click event (which requires press + release).\n *\n * @param ref - Reference to the element.\n * @param handler - Mouse press event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Button() {\n *   const ref = useRef<DOMElement>(null);\n *   const [isPressed, setIsPressed] = useState(false);\n *\n *   useOnPress(ref, () => setIsPressed(true));\n *   useOnRelease(ref, () => setIsPressed(false));\n *\n *   return (\n *     <Box ref={ref}>\n *       <Text>{isPressed ? 'Pressed!' : 'Press me'}</Text>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useOnPress(ref: ElementRef, handler: MousePressHandler | null | undefined): void {\n  useMouseEventInternal('mousePress', ref, handler);\n}\n","import type { ElementRef, MouseReleaseHandler } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling mouse button release events on an element.\n * Must be used within a MouseProvider.\n *\n * Release events fire when a mouse button is released.\n *\n * @param ref - Reference to the element.\n * @param handler - Mouse release event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Button() {\n *   const ref = useRef<DOMElement>(null);\n *   const [isPressed, setIsPressed] = useState(false);\n *\n *   useOnPress(ref, () => setIsPressed(true));\n *   useOnRelease(ref, () => setIsPressed(false));\n *\n *   return (\n *     <Box ref={ref}>\n *       <Text>{isPressed ? 'Pressed!' : 'Press me'}</Text>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useOnRelease(ref: ElementRef, handler: MouseReleaseHandler | null | undefined): void {\n  useMouseEventInternal('mouseRelease', ref, handler);\n}\n","import type { ElementRef, WheelHandler } from '../types';\nimport { useMouseEventInternal } from './useMouseEventInternal';\n\n/**\n * Hook for handling wheel (scroll) events on an element.\n * Must be used within a MouseProvider.\n *\n * @param ref - Reference to the element.\n * @param handler - Wheel event handler.\n *\n * @throws {Error} If used outside of MouseProvider\n *\n * @example\n * ```tsx\n * function Scrollable() {\n *   const ref = useRef<DOMElement>(null);\n *   const [offset, setOffset] = useState(0);\n *\n *   useOnWheel(ref, (event) => {\n *     if (event.button === 'wheel-up') {\n *       setOffset((prev) => Math.max(0, prev - 1));\n *     } else if (event.button === 'wheel-down') {\n *       setOffset((prev) => prev + 1);\n *     }\n *   });\n *\n *   return (\n *     <Box ref={ref} height={10}>\n *       <Box flexDirection=\"column\" translateY={-offset}>\n *         {items.map((item) => (\n *           <Text key={item.id}>{item.name}</Text>\n *         ))}\n *       </Box>\n *     </Box>\n *   );\n * }\n * ```\n */\nexport function useOnWheel(ref: ElementRef, handler: WheelHandler | null | undefined): void {\n  useMouseEventInternal('wheel', ref, handler);\n}\n","import type { FC, PropsWithChildren } from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { DEFAULT_PROVIDER_OPTIONS, MOUSE_EVENTS } from '../constants';\nimport { MouseContext, MouseRegistryContext } from '../context';\nimport { createMouseEventHandlers } from '../hooks/createMouseEventHandlers';\nimport { useElementBoundsCache } from '../hooks/useElementBoundsCache';\nimport { useMouseInstance } from '../hooks/useMouseInstance';\nimport type { MouseContextValue, MouseRegistryContextValue } from '../types';\n\nexport type MouseProviderProps = PropsWithChildren<{\n  readonly autoEnable?: boolean;\n  readonly cacheInvalidationMs?: number;\n}>;\n\ntype HandlerEntry = {\n  type: 'click' | 'mouseEnter' | 'mouseLeave' | 'mousePress' | 'mouseRelease' | 'mouseMove' | 'mouseDrag' | 'wheel';\n  ref: React.RefObject<unknown>;\n  handler: unknown;\n};\n\nexport const MouseProvider: FC<MouseProviderProps> = ({\n  children,\n  autoEnable = DEFAULT_PROVIDER_OPTIONS.autoEnable,\n  cacheInvalidationMs = DEFAULT_PROVIDER_OPTIONS.cacheInvalidationMs,\n}: MouseProviderProps) => {\n  const [isEnabled, setIsEnabled] = useState(false);\n\n  // Use extracted hooks for Mouse instance and cache management\n  const { mouseRef, isTracking } = useMouseInstance(autoEnable);\n  const { getCachedState, hoverStateRef } = useElementBoundsCache(cacheInvalidationMs);\n\n  // Store registered event handlers\n  const handlersRef = useRef<Map<string, HandlerEntry>>(new Map());\n\n  // Unified handler registration\n  const registerHandler = useCallback(\n    (\n      id: string,\n      ref: React.RefObject<unknown>,\n      eventType:\n        | 'click'\n        | 'mouseEnter'\n        | 'mouseLeave'\n        | 'mousePress'\n        | 'mouseRelease'\n        | 'mouseMove'\n        | 'mouseDrag'\n        | 'wheel',\n      handler: unknown,\n    ) => {\n      handlersRef.current.set(id, { type: eventType, ref, handler });\n    },\n    [],\n  );\n\n  // Unified handler unregistration\n  const unregisterHandler = useCallback((id: string) => {\n    handlersRef.current.delete(id);\n  }, []);\n\n  // Registry context value\n  const registryValue = useMemo<MouseRegistryContextValue>(\n    () => ({\n      registerHandler,\n      unregisterHandler,\n    }),\n    [registerHandler, unregisterHandler],\n  );\n\n  // Setup event listeners using extracted handler creation logic\n  useEffect((): (() => void) => {\n    const mouse = mouseRef.current;\n    if (!mouse) {\n      return () => {\n        // noop\n      };\n    }\n\n    // Create event handlers using extracted function\n    const { handleClick, handleMove, handleWheel, handlePress, handleRelease, handleDrag } = createMouseEventHandlers(\n      getCachedState,\n      hoverStateRef.current,\n      handlersRef.current,\n    );\n\n    // Register event listeners\n    mouse.on(MOUSE_EVENTS.CLICK, handleClick);\n    mouse.on(MOUSE_EVENTS.MOVE, handleMove);\n    mouse.on(MOUSE_EVENTS.WHEEL, handleWheel);\n    mouse.on(MOUSE_EVENTS.PRESS, handlePress);\n    mouse.on(MOUSE_EVENTS.RELEASE, handleRelease);\n    mouse.on(MOUSE_EVENTS.DRAG, handleDrag);\n\n    return () => {\n      // Manually remove event listeners\n      mouse.off(MOUSE_EVENTS.CLICK, handleClick);\n      mouse.off(MOUSE_EVENTS.MOVE, handleMove);\n      mouse.off(MOUSE_EVENTS.WHEEL, handleWheel);\n      mouse.off(MOUSE_EVENTS.PRESS, handlePress);\n      mouse.off(MOUSE_EVENTS.RELEASE, handleRelease);\n      mouse.off(MOUSE_EVENTS.DRAG, handleDrag);\n    };\n  }, [getCachedState, hoverStateRef, mouseRef]);\n\n  // Enable method\n  const enable = useCallback((): void => {\n    if (mouseRef.current && !isEnabled) {\n      mouseRef.current.enable();\n      setIsEnabled(true);\n    }\n  }, [isEnabled, mouseRef]);\n\n  // Disable method\n  const disable = useCallback((): void => {\n    if (mouseRef.current && isEnabled) {\n      mouseRef.current.disable();\n      setIsEnabled(false);\n    }\n  }, [isEnabled, mouseRef]);\n\n  // Context value\n  const contextValue = useMemo<MouseContextValue>(\n    () => ({\n      isEnabled,\n      isTracking,\n      enable,\n      disable,\n    }),\n    [isEnabled, isTracking, enable, disable],\n  );\n\n  return (\n    <MouseContext.Provider value={contextValue}>\n      <MouseRegistryContext.Provider value={registryValue}>{children}</MouseRegistryContext.Provider>\n    </MouseContext.Provider>\n  );\n};\n","import type { BoundingClientRect } from '../types';\n\n/**\n * Check if a point (x, y) is inside a rectangle.\n *\n * @param x - The x coordinate of the point.\n * @param y - The y coordinate of the point.\n * @param rect - The bounding rectangle.\n * @returns True if the point is inside the rectangle, false otherwise.\n *\n * @example\n * ```ts\n * const rect = { left: 10, top: 10, right: 20, bottom: 20, width: 10, height: 10, x: 10, y: 10 };\n * isPointInRect(15, 15, rect); // true\n * isPointInRect(5, 5, rect);   // false\n * ```\n */\nexport function isPointInRect(x: number, y: number, rect: BoundingClientRect): boolean {\n  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n}\n\n/**\n * Get the center point of a rectangle.\n *\n * Useful for centering elements, calculating anchor points for connectors,\n * or positioning tooltips relative to elements.\n *\n * @param rect - The bounding rectangle.\n * @returns The center point {x, y}.\n *\n * @example\n * ```ts\n * const rect = { left: 0, top: 0, right: 10, bottom: 10, width: 10, height: 10, x: 0, y: 0 };\n * getRectCenter(rect); // { x: 5, y: 5 }\n * ```\n *\n * @example\n * ```ts\n * // Position a tooltip at the center of a button\n * import { getBoundingClientRect, getRectCenter } from '@ink-tools/ink-mouse';\n *\n * const buttonRect = getBoundingClientRect(buttonRef.current);\n * if (buttonRect) {\n *   const center = getRectCenter(buttonRect);\n *   console.log(`Button center: ${center.x}, ${center.y}`);\n * }\n * ```\n */\nexport function getRectCenter(rect: BoundingClientRect): { x: number; y: number } {\n  return {\n    x: rect.left + rect.width / 2,\n    y: rect.top + rect.height / 2,\n  };\n}\n\n/**\n * Check if two rectangles overlap.\n *\n * Useful for collision detection, determining if elements intersect,\n * or checking if a dragged element overlaps with drop targets.\n *\n * @param rect1 - The first rectangle.\n * @param rect2 - The second rectangle.\n * @returns True if the rectangles overlap, false otherwise.\n *\n * @example\n * ```ts\n * const rect1 = { left: 0, top: 0, right: 10, bottom: 10, width: 10, height: 10, x: 0, y: 0 };\n * const rect2 = { left: 5, top: 5, right: 15, bottom: 15, width: 10, height: 10, x: 5, y: 5 };\n * isRectOverlapping(rect1, rect2); // true\n * ```\n *\n * @example\n * ```ts\n * // Check if a dragged element overlaps with drop zones\n * import { useBoundingClientRect, isRectOverlapping } from '@ink-tools/ink-mouse';\n *\n * function DragItem() {\n *   const dragRect = useBoundingClientRect(dragRef);\n *   const dropZoneRect = useBoundingClientRect(dropZoneRef);\n *\n *   const canDrop = dragRect && dropZoneRect && isRectOverlapping(dragRect, dropZoneRect);\n *\n *   return <Box>{canDrop ? 'Drop here!' : 'Drag over target'}</Box>;\n * }\n * ```\n */\nexport function isRectOverlapping(rect1: BoundingClientRect, rect2: BoundingClientRect): boolean {\n  return !(\n    rect1.right < rect2.left ||\n    rect1.left > rect2.right ||\n    rect1.bottom < rect2.top ||\n    rect1.top > rect2.bottom\n  );\n}\n","import type { MouseEvent as XtermMouseEvent } from 'xterm-mouse';\nimport type { BoundingClientRect } from '../types';\nimport { isPointInRect } from '../utils/geometry';\n\ntype CachedElementState = {\n  bounds?: BoundingClientRect;\n  boundsTimestamp?: number;\n};\n\nexport type HandlerEntry = {\n  type: 'click' | 'mouseEnter' | 'mouseLeave' | 'mousePress' | 'mouseRelease' | 'mouseMove' | 'mouseDrag' | 'wheel';\n  ref: React.RefObject<unknown>;\n  handler: unknown;\n};\n\n/**\n * Type guard to validate that a handler is a valid mouse event handler function.\n *\n * Performs runtime validation to ensure type safety and prevent crashes from\n * malformed or malicious handlers. This is defense-in-depth against type confusion\n * attacks and runtime errors.\n *\n * @param handler - The unknown handler to validate\n * @param eventType - The event type for error messaging\n * @returns True if the handler is a valid function that accepts mouse events\n *\n * @example\n * ```ts\n * if (!isValidHandler(entry.handler, entry.type)) {\n *   console.error(`Invalid handler for ${entry.type}`);\n *   return;\n * }\n * entry.handler(event);  // Type-safe call\n * ```\n */\nfunction isValidHandler(handler: unknown, eventType?: string): handler is (event: XtermMouseEvent) => void {\n  // Check if handler is a function\n  if (typeof handler !== 'function') {\n    if (eventType) {\n      console.error(`[ink-mouse] Invalid handler for '${eventType}' event: expected a function, got ${typeof handler}`);\n    }\n    return false;\n  }\n\n  // Check parameter count (mouse handlers should accept at least 1 argument)\n  // Note: We use <= 1 instead of === 1 because some functions (like vi.fn mocks)\n  // have length 0 but can still accept arguments\n  if (handler.length < 0 || handler.length > 10) {\n    // Unreasonably high parameter count is suspicious\n    if (eventType) {\n      console.error(\n        `[ink-mouse] Invalid handler for '${eventType}' event: function has unusual parameter count (${handler.length})`,\n      );\n    }\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates mouse event handlers for dispatching events to registered handlers\n *\n * Creates optimized event handlers that iterate through registered handlers\n * and dispatch events based on element bounds and hover state.\n *\n * This is a plain function (not a hook) because handlers are registered once\n * with the Mouse instance and don't need to be reactive.\n *\n * @param getCachedState - Function to get cached element bounds (geometry only)\n * @param hoverStateRef - WeakMap storing boolean hover state per element\n * @param handlersRef - Ref to Map of registered handlers\n * @returns Object with event handler functions\n *\n * @example\n * ```ts\n * const { handleClick, handleMove, handleWheel, ... } = createMouseEventHandlers(\n *   getCachedState,\n *   hoverStateRef,\n *   handlersRef\n * );\n *\n * // Register handlers with Mouse instance\n * mouse.on('click', handleClick);\n * mouse.on('move', handleMove);\n * ```\n */\nexport function createMouseEventHandlers(\n  getCachedState: (ref: React.RefObject<unknown>) => CachedElementState,\n  hoverStateRef: WeakMap<React.RefObject<unknown>, boolean>,\n  handlersRef: Map<string, HandlerEntry>,\n): {\n  handleClick: (event: XtermMouseEvent) => void;\n  handleMove: (event: XtermMouseEvent) => void;\n  handleWheel: (event: XtermMouseEvent) => void;\n  handlePress: (event: XtermMouseEvent) => void;\n  handleRelease: (event: XtermMouseEvent) => void;\n  handleDrag: (event: XtermMouseEvent) => void;\n} {\n  const createGenericHandler =\n    (eventType: 'click' | 'wheel' | 'mousePress' | 'mouseRelease' | 'mouseDrag') =>\n    (event: XtermMouseEvent): void => {\n      const { x, y } = event;\n\n      handlersRef.forEach((entry) => {\n        if (entry.type !== eventType) return;\n\n        if (!isValidHandler(entry.handler, eventType)) {\n          return;\n        }\n\n        const cached = getCachedState(entry.ref);\n        if (!cached.bounds) return;\n\n        if (isPointInRect(x, y, cached.bounds)) {\n          entry.handler(event);\n        }\n      });\n    };\n\n  // Move event handler (for hover and mouse move)\n  const handleMove = (event: XtermMouseEvent): void => {\n    const { x, y } = event;\n\n    // Handle all event types in a single pass\n    handlersRef.forEach((entry) => {\n      if (!['mouseMove', 'mouseEnter', 'mouseLeave'].includes(entry.type)) {\n        return;\n      }\n      if (!isValidHandler(entry.handler, entry.type)) {\n        return;\n      }\n\n      const cached = getCachedState(entry.ref);\n\n      if (!cached.bounds) return;\n\n      const isInside = isPointInRect(x, y, cached.bounds);\n\n      switch (entry.type) {\n        case 'mouseMove':\n          if (isInside) {\n            entry.handler(event);\n          }\n          break;\n\n        case 'mouseEnter': {\n          const wasHoveringEnter = hoverStateRef.get(entry.ref) ?? false;\n          if (isInside !== wasHoveringEnter) {\n            hoverStateRef.set(entry.ref, isInside);\n            if (isInside) {\n              entry.handler(event);\n            }\n          }\n          break;\n        }\n\n        case 'mouseLeave': {\n          const wasHoveringLeave = hoverStateRef.get(entry.ref) ?? false;\n          if (isInside !== wasHoveringLeave) {\n            hoverStateRef.set(entry.ref, isInside);\n            if (!isInside) {\n              entry.handler(event);\n            }\n          }\n          break;\n        }\n      }\n    });\n  };\n\n  // Create handlers from the generic factory\n  const handleClick = createGenericHandler('click');\n  const handleWheel = createGenericHandler('wheel');\n  const handlePress = createGenericHandler('mousePress');\n  const handleRelease = createGenericHandler('mouseRelease');\n  const handleDrag = createGenericHandler('mouseDrag');\n\n  return {\n    handleClick,\n    handleMove,\n    handleWheel,\n    handlePress,\n    handleRelease,\n    handleDrag,\n  };\n}\n","import type { DOMElement } from 'ink';\nimport { useStdout } from 'ink';\nimport { useCallback, useEffect, useReducer, useRef } from 'react';\nimport { getBoundingClientRect } from '../geometry';\nimport type { BoundingClientRect } from '../types';\n\ntype CachedElementState = {\n  bounds?: BoundingClientRect;\n  boundsTimestamp?: number;\n  layoutVersion?: number;\n};\n\n/**\n * Hook to manage cached element bounds for mouse event detection\n *\n * Provides efficient bounds calculation with configurable cache invalidation.\n * Uses WeakMap for automatic garbage collection when refs are released.\n *\n * Hover state is tracked separately from bounds cache to prevent race conditions\n * and ensure clean separation of concerns between geometry tracking and interaction state.\n *\n * Layout version tracking ensures cache invalidates on component re-renders and\n * terminal resize, preventing stale bounds during dynamic UI updates.\n *\n * @param cacheInvalidationMs - Cache validity period in milliseconds (default: 100)\n * @returns Object with getCachedState function and separate hoverStateRef\n *\n * @example\n * ```ts\n * const { getCachedState, hoverStateRef } = useElementBoundsCache(100);\n * const state = getCachedState(ref);\n * if (state.bounds && isPointInRect(x, y, state.bounds)) {\n *   // Handle event\n * }\n * ```\n */\nexport function useElementBoundsCache(cacheInvalidationMs: number = 100): {\n  getCachedState: (ref: React.RefObject<unknown>) => CachedElementState;\n  hoverStateRef: React.RefObject<WeakMap<React.RefObject<unknown>, boolean>>;\n} {\n  // Track layout version - increments on each render\n  const [layoutVersion] = useReducer((s: number) => s + 1, 0);\n\n  // Track terminal size for resize detection\n  const { stdout } = useStdout();\n\n  // Track cached bounds per element (ref) - geometry only\n  const boundsStateRef = useRef<WeakMap<React.RefObject<unknown>, CachedElementState>>(new WeakMap());\n\n  // Track hover state per element (ref) - interaction state only\n  const hoverStateRef = useRef<WeakMap<React.RefObject<unknown>, boolean>>(new WeakMap());\n\n  // Clear cache on terminal resize\n  // biome-ignore lint/correctness/useExhaustiveDependencies: stdout.columns and stdout.rows trigger cache clear on resize\n  useEffect(() => {\n    boundsStateRef.current = new WeakMap();\n  }, [stdout.columns, stdout.rows]);\n\n  const getCachedState = useCallback(\n    (ref: React.RefObject<unknown>): CachedElementState => {\n      const existing = boundsStateRef.current.get(ref);\n      const now = Date.now();\n\n      // Check if cache is valid (time AND layout version must match)\n      if (\n        existing?.bounds &&\n        existing.boundsTimestamp &&\n        existing.layoutVersion === layoutVersion &&\n        now - existing.boundsTimestamp < cacheInvalidationMs\n      ) {\n        return existing;\n      }\n\n      // Cache miss or expired - recalculate bounds\n      const bounds = getBoundingClientRect(ref.current as DOMElement | null);\n      const state: CachedElementState = {\n        bounds,\n        boundsTimestamp: now,\n        layoutVersion,\n      };\n\n      boundsStateRef.current.set(ref, state);\n      return state;\n    },\n    [cacheInvalidationMs, layoutVersion],\n  );\n\n  return { getCachedState, hoverStateRef };\n}\n","import { useStdin, useStdout } from 'ink';\nimport type { RefObject } from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { Mouse } from 'xterm-mouse';\nimport { DEV_WARNING, ERRORS } from '../constants';\n\n/**\n * Hook to manage Mouse instance lifecycle\n *\n * Handles creating, enabling, and cleaning up the Mouse instance.\n * Extracted from MouseProvider for better testability.\n *\n * Uses Ink's `useStdin` and `useStdout` hooks to access the streams managed\n * by Ink, ensuring proper integration with the Ink application lifecycle.\n *\n * @param autoEnable - Whether to automatically enable mouse tracking\n * @returns Object with mouseRef and isTracking state\n *\n * @example\n * ```ts\n * const { mouseRef, isTracking } = useMouseInstance(true);\n * ```\n */\nexport function useMouseInstance(autoEnable: boolean): {\n  mouseRef: RefObject<Mouse | null>;\n  isTracking: boolean;\n} {\n  const mouseRef = useRef<Mouse | null>(null);\n  const [isTracking, setIsTracking] = useState(false);\n\n  // Get Ink-managed streams and raw mode control\n  const { stdin, setRawMode } = useStdin();\n  const { stdout } = useStdout();\n\n  useEffect(() => {\n    // Check if terminal supports mouse events using the actual streams that will be used\n    if (!Mouse.isSupported(stdin, stdout)) {\n      console.warn(`${DEV_WARNING} ${ERRORS.NOT_SUPPORTED}`);\n      return (): void => {\n        // noop\n      };\n    }\n\n    // Create Mouse instance with Ink-managed streams\n    mouseRef.current = new Mouse({\n      inputStream: stdin,\n      outputStream: stdout,\n      setRawMode,\n    });\n\n    // Auto-enable if requested\n    if (autoEnable) {\n      mouseRef.current.enable();\n    }\n\n    // Set tracking state\n    setIsTracking(true);\n\n    // Cleanup function\n    return (): void => {\n      if (mouseRef.current) {\n        mouseRef.current.destroy?.();\n        mouseRef.current = null;\n      }\n      setIsTracking(false);\n    };\n  }, [autoEnable, stdin, stdout, setRawMode]);\n\n  return { mouseRef, isTracking };\n}\n","import type { InkMouseEvent } from '../types';\n\n/**\n * Check if an event has a specific modifier key pressed.\n *\n * @param event - The mouse event.\n * @param modifier - The modifier to check ('shift' | 'alt' | 'ctrl').\n * @returns True if the modifier is pressed, false otherwise.\n *\n * @example\n * ```ts\n * const event = { shift: true, alt: false, ctrl: true, ... };\n * hasModifier(event, 'shift'); // true\n * hasModifier(event, 'alt');   // false\n * ```\n */\nexport function hasModifier(event: InkMouseEvent, modifier: 'shift' | 'alt' | 'ctrl'): boolean {\n  return event[modifier];\n}\n\n/**\n * Check if any modifier key is pressed.\n *\n * @param event - The mouse event.\n * @returns True if any modifier is pressed, false otherwise.\n *\n * @example\n * ```ts\n * const event = { shift: true, alt: false, ctrl: false, ... };\n * hasAnyModifier(event); // true\n * ```\n */\nexport function hasAnyModifier(event: InkMouseEvent): boolean {\n  return event.shift || event.alt || event.ctrl;\n}\n\n/**\n * Transform an xterm-mouse event to InkMouseEvent.\n * Currently returns the event as-is since InkMouseEvent extends it.\n * This function exists for future extensibility.\n *\n * @param event - The xterm-mouse event.\n * @returns The transformed InkMouseEvent.\n */\nexport function transformEvent(event: InkMouseEvent): InkMouseEvent {\n  // Currently no transformation needed\n  // This function exists for future extensibility\n  return event;\n}\n\n/**\n * Filter events based on modifier requirements.\n *\n * @param event - The mouse event.\n * @param options - Filter options.\n * @returns True if the event matches the filter, false otherwise.\n *\n * @example\n * ```ts\n * const event = { shift: true, alt: false, ctrl: false, ... };\n *\n * // Event must have shift pressed\n * filterEvent(event, { shift: true }); // true\n *\n * // Event must have only shift pressed (no alt or ctrl)\n * filterEvent(event, { shift: true, alt: false, ctrl: false }); // true\n *\n * // Event must have no modifiers\n * filterEvent(event, { shift: false, alt: false, ctrl: false }); // false\n * ```\n */\nexport function filterEvent(\n  event: InkMouseEvent,\n  options: {\n    shift?: boolean;\n    alt?: boolean;\n    ctrl?: boolean;\n  },\n): boolean {\n  if (options.shift !== undefined && event.shift !== options.shift) {\n    return false;\n  }\n  if (options.alt !== undefined && event.alt !== options.alt) {\n    return false;\n  }\n  if (options.ctrl !== undefined && event.ctrl !== options.ctrl) {\n    return false;\n  }\n  return true;\n}\n"],"mappings":"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","names":["index_exports","__export","MouseContext","MouseProvider","filterEvent","getBoundingClientRect","getElementDimensions","getElementPosition","getRectCenter","hasAnyModifier","hasModifier","isPointInRect","isRectOverlapping","transformEvent","useBoundingClientRect","useElementDimensions","useElementPosition","useMouse","useOnClick","useOnDrag","useOnMouseEnter","useOnMouseLeave","useOnMouseMove","useOnPress","useOnRelease","useOnWheel","__toCommonJS","import_react","MouseContext","import_react","MouseRegistryContext","import_react","getElementDimensions","node","elementLayout","getElementPosition","left","top","walkNodePosition","current","layout","getBoundingClientRect","position","dimensions","width","height","right","bottom","useElementPosition","ref","deps","position","setPosition","getElementPosition","useElementDimensions","dimensions","setDimensions","getElementDimensions","useBoundingClientRect","rect","setRect","getBoundingClientRect","import_react","import_xterm_mouse","MOUSE_EVENTS","DEFAULT_PROVIDER_OPTIONS","DEV_WARNING","ERRORS","useMouse","context","MouseContext","DEV_WARNING","ERRORS","isSupported","import_react","useMouseEventInternal","eventType","ref","handler","registry","MouseRegistryContext","idRef","DEV_WARNING","ERRORS","id","useOnClick","ref","handler","useMouseEventInternal","useOnDrag","ref","handler","useMouseEventInternal","useOnMouseEnter","ref","handler","useMouseEventInternal","useOnMouseLeave","ref","handler","useMouseEventInternal","useOnMouseMove","ref","handler","useMouseEventInternal","useOnPress","ref","handler","useMouseEventInternal","useOnRelease","ref","handler","useMouseEventInternal","useOnWheel","ref","handler","useMouseEventInternal","import_react","isPointInRect","x","y","rect","getRectCenter","isRectOverlapping","rect1","rect2","isValidHandler","handler","eventType","createMouseEventHandlers","getCachedState","hoverStateRef","handlersRef","createGenericHandler","event","x","y","entry","cached","isPointInRect","handleMove","isInside","wasHoveringEnter","wasHoveringLeave","handleClick","handleWheel","handlePress","handleRelease","handleDrag","import_ink","import_react","useElementBoundsCache","cacheInvalidationMs","layoutVersion","s","stdout","boundsStateRef","hoverStateRef","ref","existing","now","state","getBoundingClientRect","import_ink","import_react","import_xterm_mouse","useMouseInstance","autoEnable","mouseRef","isTracking","setIsTracking","stdin","setRawMode","stdout","DEV_WARNING","ERRORS","import_jsx_runtime","MouseProvider","children","autoEnable","DEFAULT_PROVIDER_OPTIONS","cacheInvalidationMs","isEnabled","setIsEnabled","mouseRef","isTracking","useMouseInstance","getCachedState","hoverStateRef","useElementBoundsCache","handlersRef","registerHandler","id","ref","eventType","handler","unregisterHandler","registryValue","mouse","handleClick","handleMove","handleWheel","handlePress","handleRelease","handleDrag","createMouseEventHandlers","MOUSE_EVENTS","enable","disable","contextValue","MouseContext","MouseRegistryContext","hasModifier","event","modifier","hasAnyModifier","transformEvent","filterEvent","options"]}